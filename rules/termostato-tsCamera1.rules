// ============================================================
//  Thermostat - Camera 1
//  Controls a Daikin A/C (faikin01) to maintain a room setpoint.
//
//  Items used:
//    faikin01_power        - A/C power switch (ON/OFF)
//    faikin01_temp         - A/C target temperature
//    faikin01_fan          - A/C fan speed
//    faikin01_mode         - A/C mode: "H" (heat) or "C" (cool)
//    shelly01_Power        - Compressor power draw in Watts
//    bs02_temperature      - Sensor 1 temperature
//    bs06_temperature      - Sensor 2 temperature
//    tsSoggSensor          - Sensor selection: 1=bs02, 2=bs06, 3=average
//    tsCamera1             - Thermostat master ON/OFF
//    tsCamera1sp           - Setpoint (target temperature)
//    tsCamera1hs           - Hysteresis band
//    tsCamera1MinTemp      - Minimum allowed A/C temperature
//    tsCamera1MaxTemp      - Maximum allowed A/C temperature
//    tsCamera1Step         - Temperature adjustment step size
//    tsCamera1WaitMins     - Minutes to wait between adjustments
//    tsCamera1Wait         - Wait-timer flag (ON = cooling down between steps)
//    tsCamera1Running      - Concurrency guard (ON = rule is executing)
//    tsCamera1PowerOff     - Allow rule to power off A/C entirely (ON/OFF)
//    tsCamera1SilentOnTemp - Switch fan to silent when reducing output (ON/OFF)
//    tsCamera1AutoON       - Auto-start thermostat when A/C is turned on manually
//    tsCamera1WaitDebug    - Enable verbose debug logging
// ============================================================

val String MODE_HEAT   = "H"
val String MODE_COOL   = "C"
val String FAN_SILENT  = "Q"

// Watts below which we consider the compressor not running
val Number COMPRESSOR_IDLE_W = 40


// ============================================================
//  AUTO-ON
//  If the A/C is switched on manually and AutoON is enabled,
//  start the thermostat automatically.
// ============================================================
rule "Termostato Camera1 AutoON"
when
    Item faikin01_power changed from OFF to ON
then
    if (tsCamera1AutoON.state == ON && tsCamera1.state == OFF) {
        createTimer(now.plusSeconds(2), [|
            tsCamera1.sendCommand(ON)
            logInfo("tsCamera1", "A/C turned on manually and AutoON=ON: starting thermostat.")
        ])
    }
end


// ============================================================
//  THERMOSTAT ON
//  When the thermostat is enabled: reset state flags, turn on
//  the A/C if needed, and optionally apply startup temperature
//  and fan speed.
// ============================================================
rule "Termostato Camera1 ON"
when
    Item tsCamera1 changed from OFF to ON
then
    // Reset control flags so the main loop starts fresh
    tsCamera1Wait.sendCommand(OFF)
    tsCamera1Running.sendCommand(OFF)
    logInfo("tsCamera1", "Thermostat ON: resetting Wait and Running flags.")

    if (faikin01_power.state == OFF) {
        faikin01_power.sendCommand(ON)
        logInfo("tsCamera1", "Thermostat ON: A/C was OFF, turning it ON.")

        // Apply startup temperature after A/C has initialised
        createTimer(now.plusSeconds(2), [|
            if (tsCamera1StartupTempON.state == ON) {
                faikin01_temp.sendCommand(tsCamera1StartupTemp.state as Number)
                logInfo("tsCamera1", "Thermostat ON: applied startup temperature: " + tsCamera1StartupTemp.state)
            }
        ])

        // Apply startup fan speed (longer delay to let the unit settle)
        createTimer(now.plusSeconds(27), [|
            if (tsCamera1StartupFan.state == ON) {
                faikin01_fan.sendCommand(tsCamera1StartupFanS.state.toString)
                logInfo("tsCamera1", "Thermostat ON: applied startup fan speed: " + tsCamera1StartupFanS.state)
            }
        ])
    }
end


// ============================================================
//  THERMOSTAT OFF
//  Turn the A/C off unless an override is active.
// ============================================================
rule "Termostato Camera1 OFF"
when
    Item tsCamera1 changed from ON to OFF
then
    if (tsCamera1Override.state == OFF) {
        faikin01_power.sendCommand(OFF)
        logInfo("tsCamera1", "Thermostat OFF: turning A/C off.")
    } else {
        logInfo("tsCamera1", "Thermostat OFF: override is ON, leaving A/C running.")
    }
end


// ============================================================
//  MAIN LOOP
//  Runs every minute and after relevant item changes.
//  Reads the current room temperature and nudges the A/C
//  target temperature up or down by one step to close the gap
//  to the setpoint, respecting the hysteresis band.
//
//  Thermal states:
//    TOO COLD  →  (curTemp + hysteresis) < setpoint
//    IN RANGE  →  no action needed
//    TOO HOT   →  (curTemp - hysteresis) > setpoint
//
//  For each thermal state the action depends on mode:
//    HEAT + too cold  →  raise A/C temp (or turn A/C on)
//    HEAT + too hot   →  lower A/C temp (or turn A/C off)
//    COOL + too cold  →  raise A/C temp to reduce cooling (or turn off)
//    COOL + too hot   →  lower A/C temp to increase cooling (or turn on)
// ============================================================
rule "Termostato Camera1 Main Loop"
when
    Item tsCamera1    changed from OFF to ON or
    Item tsCamera1sp  changed or
    Item tsCamera1hs  changed or
    Time cron "0 * * * * ?"
then

    // --- Concurrency guard -------------------------------------------
    // A random small delay reduces the chance of two simultaneous
    // triggers both seeing Running=OFF and both proceeding.
    var Number jitterSec = (Math::random * 9).intValue + 1
    createTimer(now.plusSeconds(jitterSec), [|

        if (tsCamera1Running.state == ON) {
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: already running, skipping this trigger.")
            return;
        }
        tsCamera1Running.sendCommand(ON)

        // --- Early exits ------------------------------------------------
        if (tsCamera1.state != ON) {
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: thermostat is OFF, nothing to do.")
            tsCamera1Running.sendCommand(OFF)
            return;
        }
        if (tsCamera1Wait.state == ON) {
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: wait timer active, skipping this cycle.")
            tsCamera1Running.sendCommand(OFF)
            return;
        }

        // --- Read current configuration ---------------------------------
        var Number acTemp    = faikin01_temp.state as Number
        val Number acTempMax = tsCamera1MaxTemp.state as DecimalType
        val Number acTempMin = tsCamera1MinTemp.state as DecimalType
        val Number acStep    = tsCamera1Step.state as Number
        val Number hysteresis = tsCamera1hs.state as Number
        val Number setpoint  = tsCamera1sp.state as Number
        val int    waitMins  = (tsCamera1WaitMins.state as Number).intValue
        val String mode      = faikin01_mode.state.toString
        val Boolean acIsOn   = (faikin01_power.state == ON)
        val Boolean compressorIsRunning = (shelly01_Power.state as Number) >= COMPRESSOR_IDLE_W

        // --- Read room temperature (sensor selection) -------------------
        var Number curTemp
        if (tsSoggSensor.state == 1)
            curTemp = bs02_temperature.state as Number
        if (tsSoggSensor.state == 2)
            curTemp = bs06_temperature.state as Number
        if (tsSoggSensor.state == 3)
            curTemp = ((bs02_temperature.state as DecimalType) + (bs06_temperature.state as DecimalType)) / 2

        // --- Determine thermal state ------------------------------------
        val Boolean tooCold = (curTemp + hysteresis) < setpoint
        val Boolean tooHot  = (curTemp - hysteresis) > setpoint

        if (tsCamera1WaitDebug.state == ON)
            logInfo("tsCamera1", "DEBUG: curTemp=" + curTemp + " setpoint=" + setpoint +
                " hs=" + hysteresis + " acTemp=" + acTemp + " mode=" + mode +
                " acOn=" + acIsOn + " compressor=" + compressorIsRunning +
                " → tooCold=" + tooCold + " tooHot=" + tooHot)

        // --- No action needed -------------------------------------------
        if (!tooCold && !tooHot) {
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: temperature in range, no action needed.")
            tsCamera1Running.sendCommand(OFF)
            return;
        }

        // --- Start the inter-step wait timer ----------------------------
        // Prevents adjustments happening faster than tsCamera1WaitMins.
        tsCamera1Wait.sendCommand(ON)
        createTimer(now.plusMinutes(waitMins), [|
            tsCamera1Wait.sendCommand(OFF)
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: wait timer expired.")
        ])

        // --- Helpers ----------------------------------------------------

        // Raise the A/C target temperature by one step (upper-bounded by acTempMax).
        // Used both to increase heating output and to reduce cooling output.
        val raiseAcTemp = [ |
            if (acTemp < acTempMax) {
                acTemp = acTemp + acStep
                faikin01_temp.sendCommand(acTemp)
                logInfo("tsCamera1", "A/C temp raised to " + acTemp + "° (step=" + acStep + ")")
            } else {
                if (tsCamera1WaitDebug.state == ON)
                    logInfo("tsCamera1", "DEBUG: A/C temp already at maximum (" + acTempMax + "°), cannot raise further.")
            }
        ]

        // Lower the A/C target temperature by one step (lower-bounded by acTempMin).
        // Used both to increase cooling output and to reduce heating output.
        val lowerAcTemp = [ |
            if (acTemp > acTempMin) {
                acTemp = acTemp - acStep
                faikin01_temp.sendCommand(acTemp)
                logInfo("tsCamera1", "A/C temp lowered to " + acTemp + "° (step=" + acStep + ")")
            } else {
                if (tsCamera1WaitDebug.state == ON)
                    logInfo("tsCamera1", "DEBUG: A/C temp already at minimum (" + acTempMin + "°), cannot lower further.")
            }
        ]

        // Switch the fan to silent mode, with a short delay to let the
        // unit settle after a temperature change.
        val enableSilentIfAllowed = [ |
            if (tsCamera1SilentOnTemp.state == ON && faikin01_fan.state.toString != FAN_SILENT) {
                createTimer(now.plusSeconds(7), [|
                    faikin01_fan.sendCommand(FAN_SILENT)
                    logInfo("tsCamera1", "Fan switched to silent mode.")
                ])
            }
        ]

        // Turn the A/C off when the compressor is already idle —
        // only if tsCamera1PowerOff permits it.
        val turnOffIfAllowed = [ |
            if (acIsOn) {
                if (tsCamera1PowerOff.state == ON) {
                    faikin01_power.sendCommand(OFF)
                    logInfo("tsCamera1", "Compressor idle and output already minimal: A/C turned OFF.")
                } else {
                    if (tsCamera1WaitDebug.state == ON)
                        logInfo("tsCamera1", "DEBUG: Compressor idle but PowerOff is disabled, leaving A/C on.")
                }
            } else {
                if (tsCamera1WaitDebug.state == ON)
                    logInfo("tsCamera1", "DEBUG: Compressor idle and A/C already OFF, nothing to do.")
            }
        ]

        // --- Act on thermal state × mode --------------------------------

        if (tooCold && mode == MODE_HEAT) {
            // Need more heat: turn on or raise temperature
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: TOO COLD in HEAT mode — increasing output.")
            if (!acIsOn) {
                faikin01_power.sendCommand(ON)
                logInfo("tsCamera1", "A/C was OFF, turning it ON.")
            } else {
                raiseAcTemp.apply()
            }
        }

        if (tooCold && mode == MODE_COOL) {
            // Over-cooling: reduce cooling output or turn off
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: TOO COLD in COOL mode — reducing output.")
            if (!compressorIsRunning) {
                turnOffIfAllowed.apply()
            } else {
                raiseAcTemp.apply()  // higher A/C temp = less cooling
            }
            enableSilentIfAllowed.apply()
        }

        if (tooHot && mode == MODE_COOL) {
            // Need more cooling: turn on or lower temperature
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: TOO HOT in COOL mode — increasing output.")
            if (!acIsOn) {
                faikin01_power.sendCommand(ON)
                logInfo("tsCamera1", "A/C was OFF, turning it ON.")
            }
            lowerAcTemp.apply()  // lower A/C temp = more cooling
        }

        if (tooHot && mode == MODE_HEAT) {
            // Over-heating: reduce heating output or turn off
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: TOO HOT in HEAT mode — reducing output.")
            if (!compressorIsRunning) {
                turnOffIfAllowed.apply()
            } else {
                lowerAcTemp.apply()  // lower A/C temp = less heating
            }
            enableSilentIfAllowed.apply()
        }

        // Release concurrency guard
        createTimer(now.plusSeconds(3), [|
            tsCamera1Running.sendCommand(OFF)
            if (tsCamera1WaitDebug.state == ON)
                logInfo("tsCamera1", "DEBUG: finished, lock released.")
        ])

    ]) // end jitter timer

end
